#!/usr/bin/env node
import { cleanupSingleProject } from './cleanupSingleProject.js';
import { CommanderError, program } from 'commander';
import { format as formatPath, parse as parsePath, resolve as resolvePath } from 'node:path';
import { EDITOR_BUNDLE_DEFAULT, EDITOR_BUNDLE_EXTRA_DEFAULT } from './constants.js';
import { globSync } from 'glob';

interface CleanerOptions {
    editorBundle?: string,
    editorBundleExtra?: string,
    output?: string,
    replace?: boolean,
    legacyPreamble: boolean,
}

async function defaultAction(projectGlobPaths: string, options: CleanerOptions): Promise<void> {
    try {
        const projectPaths: string[] = [];
        for (const projectGlobRaw of projectGlobPaths) {
            const projectPathsRaw = globSync(projectGlobRaw);
            for (const projectPathRaw of projectPathsRaw) {
                const projectPath = resolvePath(projectPathRaw);
                if (projectPaths.indexOf(projectPath) < 0) projectPaths.push(projectPath);
            }
        }

        let outPathOverride: string | null = null;
        if (options.output) {
            if (options.replace) {
                throw new CommanderError(1, 'output-replace-clash', '--output option cannot be used with --replace flag');
            }
            if (projectPaths.length > 1) {
                throw new CommanderError(1, 'output-multiple-proj-clash', '--output option cannot be used when multiple projects are specified');
            }

            outPathOverride = resolvePath(options.output);
        }

        let editorBundle: string | null = null;
        if (options.editorBundle) {
            editorBundle = resolvePath(options.editorBundle);
        }

        let editorBundleExtra: string | null = null;
        if (options.editorBundleExtra) editorBundleExtra = resolvePath(options.editorBundleExtra);

        for (const projectPath of projectPaths) {
            if (!editorBundle) {
                editorBundle = resolvePath(parsePath(projectPath).dir, EDITOR_BUNDLE_DEFAULT);
            }

            let outputPath: string;
            if (outPathOverride) {
                outputPath = outPathOverride;
            } else if (options.replace) {
                outputPath = projectPath;
            } else {
                const tempPath = parsePath(projectPath);
                tempPath.base = `cleaned-${tempPath.base}`;
                outputPath = formatPath(tempPath);
            }

            console.log(`Cleaning up project: "${projectPath}"...`);
            await cleanupSingleProject(projectPath, outputPath, editorBundle, editorBundleExtra, options.legacyPreamble);
        }
    } catch(err) {
        if (err instanceof CommanderError) {
            program.error(err.message, { exitCode: err.exitCode, code: err.code });
        } else {
            console.error(err);
            program.error('Unexpected error occurred', { exitCode: 63, code: 'unexpected' });
        }
    }
}

program
    .argument('<project-paths...>', 'File path to project files that need to be cleaned. Each path is a glob pattern')
    .option('-o, --output <path>', 'Where the cleaned project file will be stored. Does not override the input project by default. Cannot be used with multiple project files, or with the --replace option')
    .option('-r, --replace', 'Replace the input project. Cannot be used with --output')
    .option('-b, --editor-bundle <path>', `The editor bundle that was generated by the Wonderland Editor for the input project when building (default: "<project-path directory>/${EDITOR_BUNDLE_DEFAULT}")`)
    .option('-e, --editor-bundle-extra <path>', `Add extra definitions to the editor bundle via a JS script (default: "${EDITOR_BUNDLE_EXTRA_DEFAULT}")`)
    .option('--legacy-preamble', 'Includes the legacy type definitions in the editor bundle preamble (such as Howler and window types). Note that this will be disabled by default in the future, and eventually removed', true)
    .option('--no-legacy-preamble', 'Disables the legacy type definitions in the editor bundle preamble')
    .action(defaultAction)

program.parseAsync();